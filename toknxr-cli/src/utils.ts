import chalk from 'chalk';
import axios from 'axios';
import * as fs from 'node:fs';
import * as path from 'node:path';
import { ProviderConfig } from './proxy.js'; // Assuming ProviderConfig is exported from proxy.ts

// Helper to resolve dot notation paths (copied from proxy.ts for consistency)
const getValueFromPath = (obj: unknown, path: string): number => {
  if (!path || !obj) return 0;
  try {
    const result = path.split('.').reduce((res: unknown, prop: string) =>
      res && typeof res === 'object' && prop in res ? (res as Record<string, unknown>)[prop] : undefined,
      obj
    );
    return Number(result) || 0;
  } catch {
    return 0;
  }
};

// Minimal payload for testing various providers
const TEST_PAYLOADS: { [key: string]: any } = {
  'gemini': {
    contents: [{ parts: [{ text: "Hello" }] }]
  },
  'openai': {
    model: "gpt-3.5-turbo",
    messages: [{ role: "user", content: "Hello" }]
  },
  'anthropic': {
    model: "claude-3-opus-20240229",
    messages: [{ role: "user", content: "Hello" }],
    max_tokens: 10
  },
  'ollama': {
    model: "llama3",
    prompt: "Hello",
    stream: false
  }
};

export async function testConnection(
  provider: ProviderConfig['providers'][0],
  apiKey: string | undefined
): Promise<{ ok: boolean; message?: string }> {
  const proxyUrl = `http://localhost:8788${provider.routePrefix}`;
  const testPayload = TEST_PAYLOADS[provider.name.toLowerCase().split('-')[0]] || TEST_PAYLOADS['gemini']; // Default to gemini payload

  if (!testPayload) {
    return { ok: false, message: `No test payload defined for provider: ${provider.name}` };
  }

  try {
    const headers: Record<string, string> = { 'Content-Type': 'application/json' };
    // The proxy handles adding the actual API key to the upstream request
    // We just need to ensure the proxy itself is reachable and responds
    // For the test, we don't need to pass the API key here, as the proxy will add it.
    // However, if the proxy itself fails due to missing key, that's what we want to catch.

    const res = await axios.post(proxyUrl, testPayload, {
      headers,
      timeout: 5000, // 5 second timeout
      validateStatus: () => true, // Don't throw on non-2xx status codes
    });

    if (res.status === 200) {
      // Basic check for a valid response structure
      if (res.data && (res.data.candidates || res.data.choices || res.data.response)) {
        return { ok: true };
      } else {
        return { ok: false, message: `Unexpected response format from ${provider.name}` };
      }
    } else if (res.status === 401 || res.status === 403) {
      return { ok: false, message: `Authentication failed (Status: ${res.status}). Check API key.` };
    } else if (res.status === 429) {
      return { ok: false, message: `Rate limit exceeded (Status: ${res.status}).` };
    } else if (res.status === 500 && res.data && res.data.error) {
      // Catch specific proxy errors, e.g., "API key not set"
      return { ok: false, message: `Proxy error: ${res.data.error}` };
    } else {
      return { ok: false, message: `Proxy returned status ${res.status}: ${JSON.stringify(res.data)}` };
    }
  } catch (error: any) {
    if (axios.isAxiosError(error)) {
      if (error.code === 'ECONNREFUSED' || error.code === 'ENOTFOUND') {
        return { ok: false, message: `Proxy not running or unreachable at ${proxyUrl}.` };
      } else if (error.response) {
        return { ok: false, message: `Proxy returned status ${error.response.status}: ${JSON.stringify(error.response.data)}` };
      }
      return { ok: false, message: `Network error: ${error.message}` };
    }
    return { ok: false, message: `Unknown error during connection test: ${error.message}` };
  }
}

export function generateSampleInteraction(providerName: string, logFilePath: string) {
  const sampleInteraction = {
    requestId: `sample-${Date.now()}`,
    timestamp: new Date().toISOString(),
    provider: providerName,
    model: `${providerName}-test-model`,
    promptTokens: 10,
    completionTokens: 20,
    totalTokens: 30,
    costUSD: 0.0005,
    taskType: 'chat',
    userPrompt: 'Generate a sample interaction for testing.',
    aiResponse: 'This is a sample AI response generated by the doctor command.',
    codeQualityScore: 85,
    effectivenessScore: 90,
    hallucinationDetection: {
      isLikelyHallucination: false,
      confidence: 5,
      severity: 'low',
      issues: []
    }
  };

  try {
    fs.appendFileSync(logFilePath, JSON.stringify(sampleInteraction) + '\n');
    return { ok: true, message: `Generated sample interaction for ${providerName}.` };
  } catch (error: any) {
    return { ok: false, message: `Failed to write sample interaction: ${error.message}` };
  }
}
